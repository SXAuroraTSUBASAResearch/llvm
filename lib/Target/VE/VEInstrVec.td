//===----------------------------------------------------------------------===//
// Vector Instructions
//===----------------------------------------------------------------------===//

class RV<bits<8>opVal, dag outs, dag ins, string asmstr, list<dag> pattern,
        InstrItinClass itin = NoItinerary> 
    : InstVE<outs, ins, asmstr, pattern, itin> {
    bits<1> cx = 0;
    bits<1> cx2 = 0;
    bits<1> cs = 0;   // y operand is scalar(1) or vector(0)
    bits<1> cs2 = 0;
    bits<1> cy = 0;   // y operand is register(1) or immediate(0)
    bits<8> vx;
    bits<7> sy;
    bits<8> vy;
    bits<8> vz;
    bits<8> vw;
    bits<4> m;
    let op = opVal;
    let Inst{8} = cx;
    let Inst{9} = cx2;
    let Inst{10} = cs;
    let Inst{11} = cs2;
    let Inst{15-12} = m;
    let Inst{16} = cy;
    let Inst{23-17} = sy;
    //let Inst{31-24}
    let Inst{39-32} = vx;
    let Inst{47-40} = vy;
    let Inst{55-48} = vz;
    let Inst{63-56} = vw;
}

class RV2<bits<8>opVal, dag outs, dag ins, string asmstr, list<dag> pattern,
        InstrItinClass itin = NoItinerary> 
      : RV<opVal, outs, ins, asmstr, pattern, itin> {
    let vz = 0;
    let vw = 0;
}

class RV3<bits<8>opVal, dag outs, dag ins, string asmstr, list<dag> pattern,
        InstrItinClass itin = NoItinerary> 
      : RV<opVal, outs, ins, asmstr, pattern, itin> {
    let vw = 0;
}

multiclass RVm<string opcStr, bits<8> opc> {
  // V64:$vx = (simm7:$sy or I64:$sy or V64:$vz) opc V64:$vz
  def i : RV3<opc, (outs V64:$vx), (ins simm7Op64:$sy, V64:$vz),
    !strconcat(opcStr, " $vx,$sy,$vz"), []> {
      let cs = 1;
      let cy = 0;
      let vy = 0;
      let m = 0;
    }
  def r : RV3<opc, (outs V64:$vx), (ins I64:$sy, V64:$vz),
    !strconcat(opcStr, " $vx,$sy,$vz"), []> {
      let cs = 1;
      let cy = 1;
      let vy = 0;
      let m = 0;
    }
  def v : RV3<opc, (outs V64:$vx), (ins V64:$vy, V64:$vz),
    !strconcat(opcStr, " $vx,$vy,$vz"), []> {
      let cs = 0;
      let sy = 0;
      let m = 0;
    }
  def im : RV3<opc, (outs V64:$vx), (ins simm7Op64:$sy, V64:$vz, VM:$vm),
    !strconcat(opcStr, " $vx,$sy,$vz,$vm"), []> {
      let cs = 1;
      let vy = 0;
    }
  def rm : RV3<opc, (outs V64:$vx), (ins I64:$sy, V64:$vz, VM:$vm),
    !strconcat(opcStr, " $vx,$sy,$vz,$vm"), []> {
      let cs = 1;
      let cy = 1;
      let vy = 0;
    }
  def vm : RV3<opc, (outs V64:$vx), (ins V64:$vy, V64:$vz, VM:$vm, V64:$vd),
    !strconcat(opcStr, " $vx,$vy,$vz,$vm"), []> {
      let sy = 0;
      let Constraints = "$vx = $vd";
    }
}

// Fused
multiclass RV4m<string opcStr, bits<8> opc> {
  // V64:$vx = (simm7:$sy or I64:$sy or V64:$vz) opc V64:$vz
  def v : RV<opc, (outs V64:$vx), (ins V64:$vy, V64:$vz, V64:$vw),
    !strconcat(opcStr, " $vx,$vy,$vz,$vw"), []> {
      let cs = 0;
      let cs2 = 0;

      let sy = 0;
      let m = 0;
    }
  def i : RV<opc, (outs V64:$vx), (ins simm7Op64:$sy, V64:$vz, V64:$vw),
    !strconcat(opcStr, " $vx,$sy,$vz,$vw"), []> {
      let cs = 1;
      let cs2 = 0;
      let cy = 0;

      let vy = 0;
      let m = 0;
    }
  def r : RV<opc, (outs V64:$vx), (ins I64:$sy, V64:$vz, V64:$vw),
    !strconcat(opcStr, " $vx,$sy,$vz,$vw"), []> {
      let cs = 1;
      let cs2 = 0;
      let cy = 1;

      let vy = 0;
      let m = 0;
    }
  def i2 : RV<opc, (outs V64:$vx), (ins V64:$vy, simm7Op64:$sy, V64:$vw),
    !strconcat(opcStr, " $vx,$vy,$sy,$vw"), []> {
      let cs = 0;
      let cs2 = 1;
      let cy = 0;

      let vy = 0;
      let m = 0;
    }
  def r2 : RV<opc, (outs V64:$vx), (ins V64:$vy, I64:$sy, V64:$vw),
    !strconcat(opcStr, " $vx,$vy,$sy,$vw"), []> {
      let cs = 0;
      let cs2 = 1;
      let cy = 1;

      let vy = 0;
      let m = 0;
    }
}

// u64, u32
multiclass RVLWm<string opcStr, bits<8> opc> {
  let cx2 = 0 in defm l : RVm<opcStr # ".l", opc>; // u64
  let cx2 = 1 in defm w : RVm<opcStr # ".w", opc>; // u32
}

// i32 (sz,zx)
multiclass RVEXm<string opcStr, bits<8> opc> {
  let cx2 = 0 in defm wsx : RVm<opcStr # ".w.sx", opc>; // i32 sx
  let cx2 = 1 in defm wze : RVm<opcStr # ".w.zx", opc>; // i32 zx
}

// u64, u32, packed u32
multiclass RVUm<string opcStr, bits<8> opc> {
  let cx = 0, cx2 = 0 in defm l : RVm<opcStr # ".l", opc>; // u64
  let cx = 0, cx2 = 1 in defm w : RVm<opcStr # ".w", opc>; // u32
  let cx = 1, cx2 = 1 in defm p : RVm<"p" # opcStr, opc>; // packed u32
}

// i32 (sz,zx), packed i32
multiclass RVWm<string opcStr, bits<8> opc> {
  let cx = 0, cx2 = 0 in defm wsx : RVm<opcStr # ".w.sx", opc>; // i32 sx
  let cx = 0, cx2 = 1 in defm wzx : RVm<opcStr # ".w.zx", opc>; // i32 zx
  let cx = 1, cx2 = 1 in defm p : RVm<"p" # opcStr, opc>;       // packed i32
}

// i64
multiclass RVLm<string opcStr, bits<8> opc> {
  defm l : RVm<opcStr # ".l", opc>;
}

// f64, f32, packed f32
multiclass RVDSPm<string opcStr, bits<8> opc> {
  let cx = 0, cx2 = 0 in defm d : RVm<opcStr # ".d", opc>; // double
  let cx = 1, cx2 = 0 in defm s : RVm<opcStr # ".s", opc>; // float
  let cx = 1, cx2 = 1 in defm p : RVm<"p" # opcStr, opc>; // packed
}

// f64, f32, packed f32 (4 operands)
multiclass RV4DSPm<string opcStr, bits<8> opc> {
  let cx = 0, cx2 = 0 in defm d : RV4m<opcStr # ".d", opc>; // double
  let cx = 1, cx2 = 0 in defm s : RV4m<opcStr # ".s", opc>; // float
  let cx = 1, cx2 = 1 in defm p : RV4m<"p" # opcStr, opc>; // packed
}

multiclass RVLOGm<string opcStr, bits<8> opc> {
  def v : RV3<opc, (outs V64:$vx), (ins V64:$vy, V64:$vz),
    !strconcat(opcStr, " $vx,$vy,$vz"), []> {
      let cx = 0;
      let cx2 = 0;
      let cs = 0;
  }

  def r : RV3<opc, (outs V64:$vx), (ins I64:$sy, V64:$vz),
    !strconcat(opcStr, " $vx,$sy,$vz"), []> {
      let cx = 0;
      let cx2 = 0;
      let cs = 1;
      let cy = 1;
  }

  def pv : RV3<opc, (outs V64:$vx), (ins V64:$vy, V64:$vz),
    !strconcat("p", opcStr, " $vx,$vy,$vz"), []> {
      let cx = 1;
      let cx2 = 1;
      let cs = 0;
  }

  def pr : RV3<opc, (outs V64:$vx), (ins I64:$sy, V64:$vz),
    !strconcat("p", opcStr, " $vx,$sy,$vz"), []> {
      let cx = 1;
      let cx2 = 1;
      let cs = 1;
      let cy = 1;
  }
}

multiclass RVShiftMulti<string opcStr, bits<8> opc> {
  def v : RV3<opc, (outs V64:$vx), (ins V64:$vz, V64:$vy),
    !strconcat(opcStr, " $vx,$vz,$vy"), []> {
      let cx = 0;
      let cx2 = 0;
      let cs = 0;
  }

  def r : RV3<opc, (outs V64:$vx), (ins V64:$vz, I64:$sy),
    !strconcat(opcStr, " $vx,$vz,$sy"), []> {
      let cx = 0;
      let cx2 = 0;
      let cs = 1;
      let cy = 1;
  }

  // why uimm6Op32 does not work?
  def i : RV3<opc, (outs V64:$vx), (ins V64:$vz, uimm6Op64:$sy),
    !strconcat(opcStr, " $vx,$vz,$sy"), []> {
      let cx = 0;
      let cx2 = 0;
      let cs = 1;
      let cy = 0;
  }

  def pv : RV3<opc, (outs V64:$vx), (ins V64:$vz, V64:$vy),
    !strconcat("p", opcStr, " $vx,$vz,$vy"), []> {
      let cx = 1;
      let cx2 = 1;
      let cs = 0;
  }

  def pr : RV3<opc, (outs V64:$vx), (ins V64:$vz, I64:$sy),
    !strconcat("p", opcStr, " $vx,$vz,$sy"), []> {
      let cx = 1;
      let cx2 = 1;
      let cs = 1;
      let cy = 1;
  }
}

class RVM<bits<8>opVal, dag outs, dag ins, string asmstr, list<dag> pattern,
        InstrItinClass itin = NoItinerary> 
    : InstVE<outs, ins, asmstr, pattern, itin> {
    bits<1> vo = 0; // overtake(?)
    bits<1> vc = 0; // cached(?) or uncached(?)
    bits<1> cs = 0; // use sw operand(1) or not(0)
    bits<1> cy = 0; // y operand is immediate(0) or register(1)
    bits<1> cz = 1; // z operand is zero(0) or register(1)
    bits<8> vx;
    bits<8> vy;
    bits<7> sy;
    bits<7> sz;
    bits<7> sw;
    let op = opVal;
    let Inst{8} = vo;
    let Inst{9} = vc;
    let Inst{16} = cy;
    let Inst{23-17} = sy;
    let Inst{24} = cz;
    let Inst{31-25} = sz;
    let Inst{39-32} = vx;
    let Inst{47-40} = vy;
    let Inst{63-57} = sw;
}

// VLD, VST
class RVM0<bits<8>opVal, dag outs, dag ins, string asmstr, list<dag> pattern,
        InstrItinClass itin = NoItinerary> 
    : RVM<opVal, outs, ins, asmstr, pattern, itin> {
      let vy = 0;
      let sw = 0;
}

// 5.3.2.7. Vector Transfer Instructions

multiclass VLDm<string opcStr, bits<8> opc> {
  def i : RVM0<opc, (outs V64:$vx), (ins simm7Op64:$sy, I64:$sz),
    !strconcat(opcStr, " $vx,$sy,$sz"), []> {
      let vc = 0;
      let cy = 0;
  }
  def r : RVM0<opc, (outs V64:$vx), (ins I64:$sy, I64:$sz),
    !strconcat(opcStr, " $vx,$sy,$sz"), []> {
      let vc = 0;
      let cy = 1;
  }
  def inc : RVM0<opc, (outs V64:$vx), (ins simm7Op64:$sy, I64:$sz),
    !strconcat(opcStr, ".nc $vx,$sy,$sz"), []> {
      let vc = 1;
      let cy = 0;
  }
  def rnc : RVM0<opc, (outs V64:$vx), (ins I64:$sy, I64:$sz),
    !strconcat(opcStr, ".nc $vx,$sy,$sz"), []> {
      let vc = 1;
      let cy = 1;
  }
}

multiclass VSTm<string opcStr, bits<8> opc> {
  def i : RVM0<opc, (outs), (ins V64:$vx, simm7Op64:$sy, I64:$sz),
    !strconcat(opcStr, " $vx,$sy,$sz"), []> {
      let vc = 0;
      let cy = 0;
      let cz = 1;
  }
  def r : RVM0<opc, (outs), (ins V64:$vx, I64:$sy, I64:$sz),
    !strconcat(opcStr, " $vx,$sy,$sz"), []> {
      let vc = 0;
      let cy = 1;
      let cz = 1;
  }
  def inc : RVM0<opc, (outs), (ins V64:$vx, simm7Op64:$sy, I64:$sz),
    !strconcat(opcStr, ".nc $vx,$sy,$sz"), []> {
      let vc = 1;
      let cy = 0;
      let cz = 1;
  }
  def rnc : RVM0<opc, (outs), (ins V64:$vx, I64:$sy, I64:$sz),
    !strconcat(opcStr, ".nc $vx,$sy,$sz"), []> {
      let vc = 1;
      let cy = 1;
      let cz = 1;
  }
}

let mayLoad = 1 in defm VLD : VLDm<"vld", 0x81>;
let mayLoad = 1 in defm VLDU : VLDm<"vldu", 0x82>;
let mayLoad = 1 in defm VLDL : VLDm<"vldl", 0x83>;

defm VST : VSTm<"vst", 0x91>;
defm VSTU : VSTm<"vstu", 0x92>;
defm VSTL : VSTm<"vstl", 0x93>;

def LSVr : RR<0x8E, (outs V64:$dst), (ins V64:$vx, I64:$sy, I64:$sz), 
  "lsv ${vx}(${sy}),$sz", []> {
    let cy = 1;
    let Constraints = "$dst = $vx";
}
def LSVi : RR<0x8E, (outs V64:$dst), (ins V64:$vx, simm7Op64:$sy, I64:$sz),
  "lsv ${vx}(${sy}),$sz", []> {
    let Constraints = "$dst = $vx";
}

let cx = 0, sx = 0, cy = 1, cz = 0, sz = 0 in
def LVSr : RR<0x9E, (outs I64:$sx), (ins V64:$vx, I64:$sy), "lvs ${sx},${vx}(${sy})", []>;

multiclass VBRDm<string opcStr, bits<8> opc> {
  def r : RV2<opc, (outs V64:$vx), (ins I64:$sy), 
    !strconcat(opcStr, " $vx,$sy"), []> {
      let cy = 1;
      let vy = 0;
  }
  def i : RV2<opc, (outs V64:$vx), (ins simm7Op64:$sy), 
    !strconcat(opcStr, " $vx,$sy"), []> {
      let cy = 0;
      let vy = 0;
  }
}

let cx = 0, cx2 = 0 in defm VBRD : VBRDm<"vbrd", 0x8C>;   // 64b
let cx = 1, cx2 = 0 in defm VBRDl : VBRDm<"vbrdl", 0x8C>; // 32b lower (= i32/u32)
let cx = 0, cx2 = 1 in defm VBRDu : VBRDm<"vbrdu", 0x8C>; // 32b uppper(= f32)
let cx = 1, cx2 = 1 in defm VBRDp : VBRDm<"pvbrd", 0x8C>; // 32b packed

//def : Pat<(int_ve_vbrd v256f64:$vx, i64:$sy), (VBRD v256f64:$vx, i64:$sy)>;
//def : Pat<(int_ve_vbrd v256f64:$vx, f64:$sy), (VBRD v256f64:$vx, f64:$sy)>;
//def : Pat<(int_ve_vbrdl v256f64:$vx, i32:$sy), (VBRDl v256f64:$vx, i32:$sy)>;
//def : Pat<(int_ve_vbrdu v256f64:$vx, f32:$sy), (VBRDu v256f64:$vx, i32:$sy)>;
//def : Pat<(int_ve_pvbrd v256f64:$vx, f32:$sy), (VBRDp v256f64:$vx, i32:$sy)>;

// 5.3.2.8. Vector Fixed-Point Arithmetic Operation Instructions
defm VADD : RVUm<"vaddu", 0xC8>;
defm VADS : RVWm<"vadds", 0xCA>;
defm VADX : RVLm<"vadds", 0x8B>;
defm VSUB : RVUm<"vsubu", 0xD8>;
defm VSBS : RVWm<"vsubs", 0xDA>;
defm VSBX : RVLm<"vsubs", 0x9B>;
defm VMPY : RVLWm<"vmulu", 0xC9>;   // mul unsigned 64b/32b
defm VMPS : RVEXm<"vmuls", 0xCB>; // mul signed 32b sx/zx
defm VMPX : RVLm<"vmuls", 0xDB>;   // mul signed 64b
defm VMPD : RVm<"vmuls.l.w", 0xD9>; // mul signed 32b -> 64b
// divs
defm VCMP : RVUm<"vcmpu", 0xB9>;
defm VCPS : RVWm<"vcmps", 0xFA>;
defm VCPX : RVLm<"vcmps", 0xBA>;
// CMS
// CMX

// 5.3.2.9. Vector Logical Arithmetic Operation Instructions
defm VAND : RVLOGm<"vand", 0xC4>;
defm VOR  : RVLOGm<"vor", 0xC5>;
defm VXOR : RVLOGm<"vxor", 0xC6>;
defm VEQV : RVLOGm<"veqv", 0xC7>;

// 5.3.2.10. Vector Shift Instructions
defm VSLL : RVShiftMulti<"vsll", 0xE5>;
// VSLD
defm VSRL : RVShiftMulti<"vsrl", 0xF5>;
// VSRD
// VSLA
// VSLAX
// VSRA
// VSRAX
let cy = 0, vy = 0 in
def VSFAr : RV<0xD7, (outs V64:$vx), (ins V64:$vz, simm7Op64:$sy, I64:$sz),
  "vsfa $vx,$vz,$sy,$sz", []>;
let cy = 1, vy = 0 in
def VSFAi : RV<0xD7, (outs V64:$vx), (ins V64:$vz, I64:$sy, I64:$sz),
  "vsfa $vx,$vz,$sy,$sz", []>;


// 5.3.2.11 Vector Floating-Point Arithmetic Operation Instructions
defm VFAD : RVDSPm<"vfadd", 0xCC>;
defm VFSB : RVDSPm<"vfsub", 0xDC>;
defm VFMP : RVDSPm<"vfmul", 0xCD>;
defm VFDV : RVDSPm<"vfdiv", 0xDD>;
// VFSQRT
defm VFCP : RVDSPm<"vfcmp", 0xFC>;
// VFCM
defm VFMAD : RV4DSPm<"vfmad", 0xE2>;
defm VFMSB : RV4DSPm<"vfmsb", 0xF2>;
defm VFNMAD : RV4DSPm<"vfnmad", 0xE3>;
defm VFNMSB : RV4DSPm<"vfnmsb", 0xF3>;
// VRCP
// VRSQRT
// VFIX
// VFIXX
// VFLT
// VFLTX
// VCVD
// VCVS

// 5.3.2.12. Vector Mask Arithmetic Instructions
// VMRG
// VSHF
// VCP
// VEX
// VFMK
// VFMS
// VFMF

def VFMKv : RV<0xB4, (outs VM:$vm), (ins CCOp:$cf, V64:$vz), 
  "vfmk.l.${cf} $vm,$vz", []>
{
  let sy = 0;
  let vw = 0;
}

def VFMSv : RV<0xB5, (outs VM:$vm), (ins CCOp:$cf, V64:$vz),
  "vfms.w.${cf} $vm,$vz", []>
{
  let sy = 0;
  let vw = 0;
}

def VFMFv : RV<0xB6, (outs VM:$vm), (ins CCOp:$cf, V64:$vz), 
  "vfmf.l.${cf} $vm,$vz", []>
{
  let cx = 0;
  let cx2 = 0;
  let sy = 0;
  let vw = 0;
}

def VFMFuv : RV<0xB6, (outs VM:$vm), (ins CCOp:$cf, V64:$vz), 
  "pvfmf.s.up.${cf} $vm,$vz", []>
{
  let cx = 1;
  let cx2 = 0;
  let sy = 0;
  let vw = 0;
}

def VFMFlv : RV<0xB6, (outs VM:$vm), (ins CCOp:$cf, V64:$vz), 
  "pvfmf.s.lo.${cf} $vm,$vz", []>
{
  let cx = 0;
  let cx2 = 1;
  let sy = 0;
  let vw = 0;
}



// 5.3.2.13. Vector Recursive Relation Instructions
multiclass RVRECm<string opcStr, bits<8> opc> {
  def v : RV2<opc, (outs V64:$vx), (ins V64:$vy),
    !strconcat(opcStr, " $vx,$vy"), []> {
      let sy = 0;
    }
}
let cx2 = 0 in defm VSUMSsx : RVRECm<"vsum.w.sx", 0xEA>;
let cx2 = 1 in defm VSUMSzx : RVRECm<"vsum.w.zx", 0xEA>;
defm VSUMX : RVRECm<"vsum.l", 0xAA>;
let cx = 0 in defm VFSUMd : RVRECm<"vfsum.d", 0xEC>;
let cx = 1 in defm VFSUMs : RVRECm<"vfsum.s", 0xEC>;

// 5.3.2.14. Vector Gatering/Scattering Instructions

multiclass VGTm<string opcStr, bits<8> opc> {
  def v : RVM<opc, (outs V64:$vx), (ins V64:$vy),
    !strconcat(opcStr, " $vx,$vy,0,0"), []> {
      let sy = 0;
      let sz = 0;
      let sw = 0;
  }
}

multiclass VSCm<string opcStr, bits<8> opc> {
  def v : RVM<opc, (outs), (ins V64:$vx, V64:$vy),
    !strconcat(opcStr, " $vx,$vy,0,0"), []> {
      let sy = 0;
      let sz = 0;
      let sw = 0;
  }
}

defm VGT : VGTm<"vgt", 0xA1>;
defm VGTU : VGTm<"vgtu", 0xA2>;
let vo = 0 in defm VGTLsxv : VGTm<"vgtl.sx", 0xA3>;
let vo = 1 in defm VGTLzxv : VGTm<"vgtl.zx", 0xA3>;
defm VSC : VSTm<"vsc", 0xB1>;
defm VSCU : VSTm<"vscu", 0xB2>;
defm VSCL : VSTm<"vscl", 0xB3>;

// 5.3.2.15. Vector Mask Register Instructions
// 5.3.2.16. Vector Control Instructions
// LVL
// SVL
// SMVL
// LVIX

let cx = 0, sx = 0, cy = 0, cz = 0, sz = 0 in
def LVL : RR<0xBF, (outs), (ins I32:$sy), "lvl $sy", []>;


// Pattern Matchings for Vector Instructions

def : Pat<(v256f64 (load ADDRri:$addr)), 
          (v256f64 (VLDi 8, (LEAasx ADDRri:$addr)))>;

def : Pat<(store V64:$vx, ADDRri:$addr), 
          (VSTi v256f64:$vx, 8, (LEAasx ADDRri:$addr))>;

// Pattern Matchings for Vector Intrinsics

def : Pat<(int_ve_lvl i32:$sy), (LVL i32:$sy)>;

//def : Pat<(int_ve_lsv_vss V64:$vx, I64:$sy, I64:$sz),
//          (LSVr V64:$vx, I64:$sy, I64:$sz)>;

def : Pat<(int_ve_lsv_vss v256f64:$vx, i32:$sy, i64:$sz),
          (LSVr v256f64:$vx, i32:$sy, i64:$sz)>;

def : Pat<(int_ve_vld i64:$sz, i64:$sy), (VLDr i64:$sy, i64:$sz)>;
def : Pat<(int_ve_vld i64:$sz, (i64 simm7:$sy)), (VLDi (i64 simm7:$sy), i64:$sz)>;
def : Pat<(int_ve_vldu i64:$sz, i64:$sy), (VLDUr i64:$sy, i64:$sz)>;
def : Pat<(int_ve_vldu i64:$sz, (i64 simm7:$sy)), (VLDUi (i64 simm7:$sy), i64:$sz)>;
def : Pat<(int_ve_vldl i64:$sz, i64:$sy), (VLDLr i64:$sy, i64:$sz)>;
def : Pat<(int_ve_vldl i64:$sz, (i64 simm7:$sy)), (VLDLi (i64 simm7:$sy), i64:$sz)>;

def : Pat<(int_ve_vst i64:$sz, v256f64:$vx, i64:$sy), 
          (VSTr v256f64:$vx, i64:$sy, i64:$sz)>;
def : Pat<(int_ve_vst i64:$sz, v256f64:$vx, (i64 simm7:$sy)), 
          (VSTi v256f64:$vx, (i64 simm7:$sy), i64:$sz)>;
def : Pat<(int_ve_vstu i64:$sz, v256f64:$vx, i64:$sy), 
          (VSTUr v256f64:$vx, i64:$sy, i64:$sz)>;
def : Pat<(int_ve_vstu i64:$sz, v256f64:$vx, (i64 simm7:$sy)), 
          (VSTUi v256f64:$vx, (i64 simm7:$sy), i64:$sz)>;
def : Pat<(int_ve_vstl i64:$sz, v256f64:$vx, i64:$sy), 
          (VSTLr v256f64:$vx, i64:$sy, i64:$sz)>;
def : Pat<(int_ve_vstl i64:$sz, v256f64:$vx, (i64 simm7:$sy)), 
          (VSTLi v256f64:$vx, (i64 simm7:$sy), i64:$sz)>;


//def : Pat<(int_ve_pvfmad_vvSv v256f64:$vy, f32:$sy0, f32:$sy1, 

include "VEInstrIntrinsic.td"

