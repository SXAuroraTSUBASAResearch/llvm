//===-- VERegisterInfo.td - VE Register defs ---------------*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
//  Declarations that describe the VE register file
//===----------------------------------------------------------------------===//

class VEReg<bits<7> Enc, string n> : Register<n> {
  let HWEncoding{15-7} = 0;
  let HWEncoding{6-0} = Enc;
  let Namespace = "VE";
}

class VEMiscReg<bits<5> Enc, string n>: Register<n> {
  let HWEncoding{15-5} = 0;
  let HWEncoding{4-0} = Enc;
  let Namespace = "VE";
}

let Namespace = "VE" in {
def sub_even : SubRegIndex<64>;
def sub_odd  : SubRegIndex<64, 64>;
}

// Registers are identified with 7-bit ID numbers.
// R - 64-bit integer or floating-point registers
class R<bits<7> Enc, string n> : VEReg<Enc, n>;

// Rq - Slots in the register file for 128-bit floating-point values.
class Rq<bits<7> Enc, string n, list<Register> subregs> : VEReg<Enc, n> {
  let SubRegs = subregs;
  let SubRegIndices = [sub_even, sub_odd];
  let CoveredBySubRegs = 1;
}

// Vector Registers are identified with 7-bit ID numbers.
// VR - 64-bit wide 256 elements integer or floating-point registers
class VR<bits<7> Enc, string n> : VEReg<Enc, n>;

// Vector Mask Registers are identified with 5-bit ID numbers.
// VM - 256-bit wide mask registers
class VM<bits<7> Enc, string n> : VEReg<Enc, n>;

// Miscellaneous Registers
def UCC : VEMiscReg<0, "UCC">;       // User clock counter
def PSW : VEMiscReg<1, "PSW">;       // Program status word
def SAR : VEMiscReg<2, "SAR">;       // Store address register
def PMMR : VEMiscReg<7, "PMMR">;     // Performance monitor mode register

// Performance monitor configuration registers
foreach I = 0-3 in
  def PMCR#I : VEMiscReg<!add(8,I), "PMCR"#I>;

// Performance monitor counter
foreach I = 0-14 in
  def PMC#I : VEMiscReg<!add(16,I), "PMC"#I>;

// Generic registers - 64 bits wide
foreach I = 0-63 in
  def S#I : R<I, "S"#I>, DwarfRegNum<[I]>;

// Vector registers - 64 bits wide 256 elements
foreach I = 0-63 in
  def V#I : VR<I, "V"#I>, DwarfRegNum<[!add(64,I)]>;

// Vector mask registers - 256 bits wide
foreach I = 0-15 in
  def VM#I : VM<I, "VM"#I>, DwarfRegNum<[!add(128,I)]>;

// Aliases of the S* registers used to hold 128-bit for values (long doubles).
// Following foreach represents something like:
//   def Q0 : Rq<0, "S0", [S0, S1]>;
//   def Q1 : Rq<2, "S2", [S2, S3]>;
//   ...
foreach I = 0-31 in
  def Q#I : Rq<!shl(I,1),  "S"#!shl(I,1),
               [!cast<R>("S"#!shl(I,1)),
                !cast<R>("S"#!add(!shl(I,1),1))]>;

// Register classes.
//
// The register order is defined in terms of the preferred
// allocation order.
def I8 : RegisterClass<"VE", [i8], 8,
                        (add (sequence "S%u", 34, 63),
                             (sequence "S%u", 0, 33))>;
def I16 : RegisterClass<"VE", [i16], 16,
                        (add (sequence "S%u", 34, 63),
                             (sequence "S%u", 0, 33))>;
def I32 : RegisterClass<"VE", [i32], 32,
                        (add (sequence "S%u", 34, 63),
                             (sequence "S%u", 0, 33))>;
def I64 : RegisterClass<"VE", [i64], 64,
                        (add (sequence "S%u", 34, 63),
                             (sequence "S%u", 0, 33))>;
def F32 : RegisterClass<"VE", [f32], 32,
                        (add (sequence "S%u", 34, 63),
                             (sequence "S%u", 0, 33))>;
def F64 : RegisterClass<"VE", [f64], 64,
                        (add (sequence "S%u", 34, 63),
                             (sequence "S%u", 0, 33))>;
def F128 : RegisterClass<"VE", [f128], 128, (sequence "Q%u", 0, 31)>;

def Misc : RegisterClass<"VE", [i64], 64,
                         (add UCC, PSW, SAR, PMMR,
                              (sequence "PMCR%u", 0, 3),
                              (sequence "PMC%u", 0, 14))>;

